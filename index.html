<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Alpha Bleed Fix</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: #0f0f0f;
      color: #e0e0e0;
      min-height: 100vh;
    }

    header {
      text-align: center;
      padding: 2rem 1rem 1rem;
    }

    header h1 {
      font-size: 1.8rem;
      font-weight: 600;
      color: #fff;
    }

    header p {
      color: #888;
      margin-top: .4rem;
      font-size: .95rem;
    }

    .container {
      max-width: 1100px;
      margin: 0 auto;
      padding: 1rem;
    }

    /* Drop zone */
    .drop-zone {
      border: 2px dashed #333;
      border-radius: 12px;
      padding: 3rem 1rem;
      text-align: center;
      cursor: pointer;
      transition: border-color .2s, background .2s;
      position: relative;
    }

    .drop-zone:hover,
    .drop-zone.dragover {
      border-color: #4a9eff;
      background: rgba(74, 158, 255, .05);
    }

    .drop-zone input {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    .drop-zone .icon {
      font-size: 2.5rem;
      margin-bottom: .5rem;
    }

    .drop-zone .label {
      font-size: 1.1rem;
      color: #aaa;
    }

    .drop-zone .sublabel {
      font-size: .85rem;
      color: #555;
      margin-top: .3rem;
    }

    /* Controls */
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: end;
      margin-top: 1.5rem;
      padding: 1rem;
      background: #181818;
      border-radius: 10px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: .3rem;
    }

    .control-group label {
      font-size: .8rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: .5px;
    }

    .control-group input,
    .control-group select {
      background: #222;
      border: 1px solid #333;
      color: #e0e0e0;
      padding: .45rem .6rem;
      border-radius: 6px;
      font-size: .9rem;
      width: 140px;
    }

    .control-group input:focus,
    .control-group select:focus {
      outline: none;
      border-color: #4a9eff;
    }

    .spacer { flex: 1; }

    .btn {
      padding: .55rem 1.2rem;
      border: none;
      border-radius: 8px;
      font-size: .9rem;
      font-weight: 500;
      cursor: pointer;
      transition: background .15s, opacity .15s;
    }

    .btn:disabled {
      opacity: .4;
      cursor: not-allowed;
    }

    .btn-primary {
      background: #4a9eff;
      color: #fff;
    }

    .btn-primary:hover:not(:disabled) { background: #3a8eef; }

    .btn-danger {
      background: #333;
      color: #e55;
    }

    .btn-danger:hover:not(:disabled) { background: #3a3a3a; }

    .btn-success {
      background: #2ecc71;
      color: #fff;
    }

    .btn-success:hover:not(:disabled) { background: #27ae60; }

    /* Thumbnails */
    .thumbnails {
      display: flex;
      flex-wrap: wrap;
      gap: .5rem;
      margin-top: 1.5rem;
    }

    .thumb {
      position: relative;
      width: 80px;
      height: 80px;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid #333;
      background: #1a1a1a;
    }

    .thumb img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .thumb .remove {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 20px;
      height: 20px;
      background: rgba(0,0,0,.7);
      color: #e55;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 14px;
      line-height: 20px;
      text-align: center;
      display: none;
    }

    .thumb:hover .remove { display: block; }

    .thumb .status-badge {
      position: absolute;
      bottom: 2px;
      left: 2px;
      padding: 1px 5px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 600;
      pointer-events: none;
    }

    .thumb .status-badge.done {
      background: rgba(46, 204, 113, .85);
      color: #fff;
    }

    .thumb .status-badge.processing {
      background: rgba(74, 158, 255, .85);
      color: #fff;
    }

    /* Preview */
    .preview-section {
      margin-top: 2rem;
    }

    .preview-section h2 {
      font-size: 1.1rem;
      font-weight: 500;
      margin-bottom: .8rem;
      color: #aaa;
    }

    .preview-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }

    @media (max-width: 700px) {
      .preview-grid {
        grid-template-columns: 1fr;
      }
    }

    .preview-card {
      background: #181818;
      border: 1px solid #333;
      border-radius: 10px;
      overflow: hidden;
    }

    .preview-card-header {
      padding: .6rem 1rem;
      font-size: .85rem;
      color: #888;
      border-bottom: 1px solid #282828;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .preview-card-header .filename {
      color: #ccc;
      font-weight: 500;
    }

    .preview-card-header .dimensions {
      color: #555;
      font-size: .8rem;
    }

    .preview-card-body {
      background: repeating-conic-gradient(#222 0% 25%, #2a2a2a 0% 50%) 50% / 20px 20px;
      padding: 1rem;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 150px;
    }

    .preview-card-body canvas,
    .preview-card-body img {
      max-width: 100%;
      height: auto;
      display: block;
    }

    /* Progress */
    .progress-bar-container {
      margin-top: 1.5rem;
      display: none;
    }

    .progress-bar-container.visible {
      display: block;
    }

    .progress-label {
      font-size: .85rem;
      color: #888;
      margin-bottom: .4rem;
      display: flex;
      justify-content: space-between;
    }

    .progress-track {
      height: 6px;
      background: #222;
      border-radius: 3px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: #4a9eff;
      border-radius: 3px;
      transition: width .3s;
      width: 0%;
    }

    /* Info box */
    .info-box {
      margin-top: 1.5rem;
      padding: 1rem;
      background: #181818;
      border: 1px solid #333;
      border-radius: 10px;
      font-size: .85rem;
      color: #888;
      line-height: 1.6;
    }

    .info-box strong {
      color: #aaa;
    }

    footer {
      text-align: center;
      padding: 2rem 1rem;
      color: #444;
      font-size: .8rem;
    }

    footer a {
      color: #4a9eff;
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>

<header>
  <h1>Alpha Bleed Fix</h1>
  <p>Fix dark edges on transparent images caused by bilinear interpolation</p>
</header>

<div class="container">

  <div class="drop-zone" id="dropZone">
    <input type="file" id="fileInput" multiple accept="image/png,image/webp">
    <div class="icon">+</div>
    <div class="label">Drop images here or click to browse</div>
    <div class="sublabel">PNG, WebP &mdash; images with transparency</div>
  </div>

  <div class="controls">
    <div class="spacer"></div>
    <button class="btn btn-danger" id="clearBtn" disabled>Clear All</button>
    <button class="btn btn-primary" id="processBtn" disabled>Fix Images</button>
    <button class="btn btn-success" id="downloadBtn" disabled>Download All</button>
  </div>

  <div class="thumbnails" id="thumbnails"></div>

  <div class="progress-bar-container" id="progressContainer">
    <div class="progress-label">
      <span id="progressText">Processing...</span>
      <span id="progressPercent">0%</span>
    </div>
    <div class="progress-track">
      <div class="progress-fill" id="progressFill"></div>
    </div>
  </div>

  <div class="preview-section" id="previewSection" style="display:none">
    <h2>Before &amp; After</h2>
    <div id="previewList"></div>
  </div>

  <div class="info-box">
    <strong>What is alpha bleeding?</strong><br>
    When images with transparency are scaled using bilinear interpolation (as Roblox does),
    the GPU averages nearby pixel colors &mdash; including fully transparent pixels that often
    contain black (0, 0, 0) RGB values. This causes dark edges/fringing around transparent
    boundaries. Alpha bleeding fills the RGB of transparent pixels with colors from their
    nearest opaque neighbors, so interpolation produces correct results while keeping the
    alpha channel unchanged.
  </div>

</div>

<footer>
  Alpha Bleed Fix &mdash; runs entirely in your browser &mdash;
  <a href="https://github.com/gatekeeperdev/alpha-bleed-fix" target="_blank">GitHub</a>
</footer>

<script>
// --- PNG encoder from https://github.com/wheany/js-png-encoder ---
// Encodes raw RGBA pixel data directly to PNG, bypassing canvas export
// which would premultiply alpha and destroy RGB on transparent pixels.
(function (globalObj) {
  'use strict';
  var DEFLATE_METHOD = String.fromCharCode(0x78, 0x01),
      CRC_TABLE = [],
      SIGNATURE = String.fromCharCode(137, 80, 78, 71, 13, 10, 26, 10),
      NO_FILTER = String.fromCharCode(0);

  function make_crc_table() {
    for (var n = 0; n < 256; n++) {
      var c = n;
      for (var k = 0; k < 8; k++) {
        c = (c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1);
      }
      CRC_TABLE[n] = c;
    }
  }

  function inflateStore(data) {
    var MAX = 65535, buf = '', i, rem, bt;
    for (i = 0; i < data.length; i += MAX) {
      rem = data.length - i;
      bt = (rem <= MAX) ? String.fromCharCode(0x01) : String.fromCharCode(0x00);
      if (rem > MAX) rem = MAX;
      buf += bt + String.fromCharCode(rem & 0xFF, (rem & 0xFF00) >>> 8);
      buf += String.fromCharCode((~rem) & 0xFF, ((~rem) & 0xFF00) >>> 8);
      buf += data.substring(i, i + rem);
    }
    return buf;
  }

  function adler32(data) {
    var a = 1, b = 0;
    for (var i = 0; i < data.length; i++) {
      a = (a + data.charCodeAt(i)) % 65521;
      b = (b + a) % 65521;
    }
    return (b << 16) | a;
  }

  function update_crc(crc, buf) {
    var c = crc;
    for (var n = 0; n < buf.length; n++) {
      c = CRC_TABLE[(c ^ buf.charCodeAt(n)) & 0xff] ^ (c >>> 8);
    }
    return c;
  }

  function crc(buf) { return update_crc(0xffffffff, buf) ^ 0xffffffff; }

  function dword(d) {
    return String.fromCharCode((d & 0xFF000000) >>> 24, (d & 0x00FF0000) >>> 16,
                               (d & 0x0000FF00) >>> 8, d & 0x000000FF);
  }

  function createChunk(length, type, data) {
    return dword(length) + type + data + dword(crc(type + data));
  }

  make_crc_table();
  var IEND = createChunk(0, 'IEND', '');

  function createIHDR(w, h) {
    var d = dword(w) + dword(h);
    d += String.fromCharCode(8, 6, 0, 0, 0); // 8-bit RGBA, no interlace
    return createChunk(13, 'IHDR', d);
  }

  globalObj.generatePng = function(width, height, rgba) {
    var IHDR = createIHDR(width, height), scanlines = '';
    for (var y = 0; y < rgba.length; y += width * 4) {
      scanlines += NO_FILTER;
      if (Array.isArray(rgba)) {
        for (var x = 0; x < width * 4; x++) {
          scanlines += String.fromCharCode(rgba[y + x] & 0xff);
        }
      } else {
        scanlines += rgba.substr(y, width * 4);
      }
    }
    var compressed = DEFLATE_METHOD + inflateStore(scanlines) + dword(adler32(scanlines));
    return SIGNATURE + IHDR + createChunk(compressed.length, 'IDAT', compressed) + IEND;
  };
}(window));

function rawImageDataToString(dat) {
  var s = '';
  for (var i = 0; i < dat.length; i++) { s += String.fromCharCode(dat[i]); }
  return s;
}

// --- SimpleImage wrapper for pixel access ---
function SimpleImage(canvas) {
  this.canvas = canvas;
  this.context = canvas.getContext('2d');
  this.width = canvas.width;
  this.height = canvas.height;
  this.imageData = this.context.getImageData(0, 0, this.width, this.height);
  this.data = this.imageData.data;
}
SimpleImage.prototype.getRGB = function(x, y) {
  var i = (y * this.width + x) * 4;
  return { r: this.data[i], g: this.data[i+1], b: this.data[i+2], a: this.data[i+3] };
};
SimpleImage.prototype.setRGB = function(x, y, px) {
  var i = (y * this.width + x) * 4;
  this.data[i] = px.r; this.data[i+1] = px.g; this.data[i+2] = px.b;
  this.data[i+3] = ('a' in px) ? px.a : 255;
};
SimpleImage.prototype.getRawData = function() { return this.data; };

// --- Alpha bleed algorithm from https://github.com/urraka/alpha-bleeding ---
function bleedAlpha(canvas) {
  var simg = new SimpleImage(canvas);
  var width = canvas.width, height = canvas.height;

  var opaque = [], loose = [], pending = [], pendingNext = [];
  for (var y = 0; y < height; y++) {
    opaque[y] = [];
    loose[y] = [];
    for (var x = 0; x < width; x++) {
      opaque[y][x] = 0;
      loose[y][x] = false;
    }
  }

  var offsets = [[-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1]];

  for (var y = 0; y < height; y++) {
    for (var x = 0; x < width; x++) {
      var pixel = simg.getRGB(x, y);
      if (pixel.a == 0) {
        var isLoose = true;
        for (var k = 0; k < 8; k++) {
          var nX = x + offsets[k][0], nY = y + offsets[k][1];
          if (nX >= 0 && nX < width && nY >= 0 && nY < height) {
            if (simg.getRGB(nX, nY).a != 0) { isLoose = false; break; }
          }
        }
        if (!isLoose) { pending.push({x: x, y: y}); }
        else { loose[y][x] = true; }
      } else {
        opaque[y][x] = -1;
      }
    }
  }

  while (pending.length > 0) {
    pendingNext = [];
    for (var p = 0; p < pending.length; p++) {
      var coord = pending[p], x = coord.x, y = coord.y;
      var r = 0, g = 0, b = 0, count = 0;
      for (var k = 0; k < 8; k++) {
        var nX = x + offsets[k][0], nY = y + offsets[k][1];
        if (nX >= 0 && nX < width && nY >= 0 && nY < height) {
          if (opaque[nY][nX] & 1) {
            var neighbor = simg.getRGB(nX, nY);
            r += neighbor.r; g += neighbor.g; b += neighbor.b;
            count++;
          }
        }
      }
      if (count > 0) {
        simg.setRGB(x, y, {r: r/count, g: g/count, b: b/count, a: 0});
        opaque[y][x] = 0xFE;
        for (var k = 0; k < 8; k++) {
          var nX = x + offsets[k][0], nY = y + offsets[k][1];
          if (nX >= 0 && nX < width && nY >= 0 && nY < height) {
            if (loose[nY][nX]) { pendingNext.push({x: nX, y: nY}); loose[nY][nX] = false; }
          }
        }
      } else {
        pendingNext.push({x: x, y: y});
      }
    }
    if (pendingNext.length > 0) {
      for (var p = 0; p < pending.length; p++) {
        var coord = pending[p];
        opaque[coord.y][coord.x] >>= 1;
      }
    }
    pending = pendingNext;
  }

  var dat = simg.getRawData();
  return btoa(generatePng(width, height, rawImageDataToString(dat)));
}

// --- Main UI ---
(function () {
  var dropZone = document.getElementById('dropZone');
  var fileInput = document.getElementById('fileInput');
  var thumbnailsEl = document.getElementById('thumbnails');
  var clearBtn = document.getElementById('clearBtn');
  var processBtn = document.getElementById('processBtn');
  var downloadBtn = document.getElementById('downloadBtn');
  var progressContainer = document.getElementById('progressContainer');
  var progressText = document.getElementById('progressText');
  var progressPercent = document.getElementById('progressPercent');
  var progressFill = document.getElementById('progressFill');
  var previewSection = document.getElementById('previewSection');
  var previewList = document.getElementById('previewList');

  var images = []; // { name, img, w, h, fixedDataUrl, processed }

  // --- File handling ---

  dropZone.addEventListener('dragover', function(e) {
    e.preventDefault();
    dropZone.classList.add('dragover');
  });

  dropZone.addEventListener('dragleave', function() {
    dropZone.classList.remove('dragover');
  });

  dropZone.addEventListener('drop', function(e) {
    e.preventDefault();
    dropZone.classList.remove('dragover');
    handleFiles(e.dataTransfer.files);
  });

  fileInput.addEventListener('change', function(e) {
    handleFiles(e.target.files);
    fileInput.value = '';
  });

  function handleFiles(fileList) {
    var files = Array.from(fileList).filter(function(f) { return f.type.startsWith('image/'); });
    if (!files.length) return;

    var promises = files.map(function(file) {
      return new Promise(function(resolve) {
        var reader = new FileReader();
        reader.onload = function(e) {
          var img = new Image();
          img.onload = function() {
            resolve({
              name: file.name.replace(/\.[^.]+$/, ''),
              img: img,
              w: img.naturalWidth,
              h: img.naturalHeight,
              fixedDataUrl: null,
              processed: false
            });
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      });
    });

    Promise.all(promises).then(function(newImages) {
      images = images.concat(newImages);
      downloadBtn.disabled = true;
      updateUI();
    });
  }

  // --- UI ---

  function updateUI() {
    renderThumbnails();
    clearBtn.disabled = images.length === 0;
    processBtn.disabled = images.length === 0;
    if (images.length === 0) {
      previewSection.style.display = 'none';
      downloadBtn.disabled = true;
      progressContainer.classList.remove('visible');
    }
  }

  function renderThumbnails() {
    thumbnailsEl.innerHTML = '';
    images.forEach(function(item, i) {
      var div = document.createElement('div');
      div.className = 'thumb';
      div.title = item.name + ' (' + item.w + '\u00d7' + item.h + ')';

      var img = document.createElement('img');
      img.src = item.img.src;
      div.appendChild(img);

      var btn = document.createElement('button');
      btn.className = 'remove';
      btn.textContent = '\u00d7';
      btn.onclick = (function(idx) { return function() {
        images.splice(idx, 1);
        downloadBtn.disabled = true;
        updateUI();
        renderPreviews();
      }; })(i);
      div.appendChild(btn);

      if (item.processed) {
        var badge = document.createElement('span');
        badge.className = 'status-badge done';
        badge.textContent = 'Fixed';
        div.appendChild(badge);
      }

      thumbnailsEl.appendChild(div);
    });
  }

  // --- Processing ---

  async function processImages() {
    processBtn.disabled = true;
    downloadBtn.disabled = true;
    progressContainer.classList.add('visible');

    for (var idx = 0; idx < images.length; idx++) {
      var item = images[idx];
      var pct = Math.round((idx / images.length) * 100);
      progressText.textContent = 'Processing ' + (idx + 1) + ' of ' + images.length + '...';
      progressPercent.textContent = pct + '%';
      progressFill.style.width = pct + '%';

      // Yield to UI
      await new Promise(function(r) { setTimeout(r, 0); });

      // Draw original image to a temp canvas
      var canvas = document.createElement('canvas');
      canvas.width = item.w;
      canvas.height = item.h;
      var ctx = canvas.getContext('2d');
      ctx.drawImage(item.img, 0, 0);

      // Run the bleed algorithm â€” returns base64 PNG encoded directly from raw pixels
      var resultBase64 = bleedAlpha(canvas);
      item.fixedDataUrl = 'data:image/png;base64,' + resultBase64;
      item.processed = true;

      renderThumbnails();
    }

    progressText.textContent = 'Done!';
    progressPercent.textContent = '100%';
    progressFill.style.width = '100%';

    setTimeout(function() {
      progressContainer.classList.remove('visible');
    }, 1500);

    processBtn.disabled = false;
    downloadBtn.disabled = false;

    renderPreviews();
  }

  function renderPreviews() {
    var processed = images.filter(function(item) { return item.processed; });
    if (processed.length === 0) {
      previewSection.style.display = 'none';
      return;
    }

    previewSection.style.display = 'block';
    previewList.innerHTML = '';

    processed.forEach(function(item) {
      var grid = document.createElement('div');
      grid.className = 'preview-grid';
      grid.style.marginBottom = '1.5rem';

      // Before card
      var beforeCard = document.createElement('div');
      beforeCard.className = 'preview-card';
      var beforeHeader = document.createElement('div');
      beforeHeader.className = 'preview-card-header';
      beforeHeader.innerHTML = '<span class="filename">Before &mdash; ' + item.name + '</span><span class="dimensions">' + item.w + '\u00d7' + item.h + '</span>';
      var beforeBody = document.createElement('div');
      beforeBody.className = 'preview-card-body';
      var beforeImg = document.createElement('img');
      beforeImg.src = item.img.src;
      beforeImg.style.maxWidth = '100%';
      beforeBody.appendChild(beforeImg);
      beforeCard.appendChild(beforeHeader);
      beforeCard.appendChild(beforeBody);

      // After card
      var afterCard = document.createElement('div');
      afterCard.className = 'preview-card';
      var afterHeader = document.createElement('div');
      afterHeader.className = 'preview-card-header';
      afterHeader.innerHTML = '<span class="filename">After &mdash; ' + item.name + '</span><span class="dimensions">' + item.w + '\u00d7' + item.h + '</span>';
      var afterBody = document.createElement('div');
      afterBody.className = 'preview-card-body';
      var afterImg = document.createElement('img');
      afterImg.src = item.fixedDataUrl;
      afterImg.style.maxWidth = '100%';
      afterBody.appendChild(afterImg);
      afterCard.appendChild(afterHeader);
      afterCard.appendChild(afterBody);

      grid.appendChild(beforeCard);
      grid.appendChild(afterCard);
      previewList.appendChild(grid);
    });
  }

  // --- Download ---

  function dataUrlToBlob(dataUrl) {
    var parts = dataUrl.split(',');
    var mime = parts[0].match(/:(.*?);/)[1];
    var raw = atob(parts[1]);
    var arr = new Uint8Array(raw.length);
    for (var i = 0; i < raw.length; i++) arr[i] = raw.charCodeAt(i);
    return new Blob([arr], { type: mime });
  }

  function downloadAll() {
    var processed = images.filter(function(item) { return item.processed; });
    if (processed.length === 0) return;

    if (processed.length === 1) {
      var blob = dataUrlToBlob(processed[0].fixedDataUrl);
      var url = URL.createObjectURL(blob);
      var a = document.createElement('a');
      a.href = url;
      a.download = processed[0].name + '_fixed.png';
      a.click();
      URL.revokeObjectURL(url);
    } else {
      downloadAsZip(processed);
    }
  }

  async function downloadAsZip(items) {
    if (typeof JSZip === 'undefined') {
      await new Promise(function(resolve, reject) {
        var script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }

    var zip = new JSZip();
    for (var i = 0; i < items.length; i++) {
      var blob = dataUrlToBlob(items[i].fixedDataUrl);
      zip.file(items[i].name + '_fixed.png', blob);
    }

    var content = await zip.generateAsync({ type: 'blob' });
    var url = URL.createObjectURL(content);
    var a = document.createElement('a');
    a.href = url;
    a.download = 'alpha_bleed_fixed.zip';
    a.click();
    URL.revokeObjectURL(url);
  }

  // --- Controls ---

  clearBtn.addEventListener('click', function() {
    images = [];
    updateUI();
  });

  processBtn.addEventListener('click', function() {
    processImages();
  });

  downloadBtn.addEventListener('click', function() {
    downloadAll();
  });
})();
</script>

</body>
</html>
