<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Alpha Bleed Fix</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: #0f0f0f;
      color: #e0e0e0;
      min-height: 100vh;
    }

    header {
      text-align: center;
      padding: 2rem 1rem 1rem;
    }

    header h1 {
      font-size: 1.8rem;
      font-weight: 600;
      color: #fff;
    }

    header p {
      color: #888;
      margin-top: .4rem;
      font-size: .95rem;
    }

    .container {
      max-width: 1100px;
      margin: 0 auto;
      padding: 1rem;
    }

    /* Drop zone */
    .drop-zone {
      border: 2px dashed #333;
      border-radius: 12px;
      padding: 3rem 1rem;
      text-align: center;
      cursor: pointer;
      transition: border-color .2s, background .2s;
      position: relative;
    }

    .drop-zone:hover,
    .drop-zone.dragover {
      border-color: #4a9eff;
      background: rgba(74, 158, 255, .05);
    }

    .drop-zone input {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    .drop-zone .icon {
      font-size: 2.5rem;
      margin-bottom: .5rem;
    }

    .drop-zone .label {
      font-size: 1.1rem;
      color: #aaa;
    }

    .drop-zone .sublabel {
      font-size: .85rem;
      color: #555;
      margin-top: .3rem;
    }

    /* Controls */
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: end;
      margin-top: 1.5rem;
      padding: 1rem;
      background: #181818;
      border-radius: 10px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: .3rem;
    }

    .control-group label {
      font-size: .8rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: .5px;
    }

    .control-group input,
    .control-group select {
      background: #222;
      border: 1px solid #333;
      color: #e0e0e0;
      padding: .45rem .6rem;
      border-radius: 6px;
      font-size: .9rem;
      width: 140px;
    }

    .control-group input:focus,
    .control-group select:focus {
      outline: none;
      border-color: #4a9eff;
    }

    .spacer { flex: 1; }

    .btn {
      padding: .55rem 1.2rem;
      border: none;
      border-radius: 8px;
      font-size: .9rem;
      font-weight: 500;
      cursor: pointer;
      transition: background .15s, opacity .15s;
    }

    .btn:disabled {
      opacity: .4;
      cursor: not-allowed;
    }

    .btn-primary {
      background: #4a9eff;
      color: #fff;
    }

    .btn-primary:hover:not(:disabled) { background: #3a8eef; }

    .btn-danger {
      background: #333;
      color: #e55;
    }

    .btn-danger:hover:not(:disabled) { background: #3a3a3a; }

    .btn-success {
      background: #2ecc71;
      color: #fff;
    }

    .btn-success:hover:not(:disabled) { background: #27ae60; }

    /* Thumbnails */
    .thumbnails {
      display: flex;
      flex-wrap: wrap;
      gap: .5rem;
      margin-top: 1.5rem;
    }

    .thumb {
      position: relative;
      width: 80px;
      height: 80px;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid #333;
      background: #1a1a1a;
    }

    .thumb img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .thumb .remove {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 20px;
      height: 20px;
      background: rgba(0,0,0,.7);
      color: #e55;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 14px;
      line-height: 20px;
      text-align: center;
      display: none;
    }

    .thumb:hover .remove { display: block; }

    .thumb .status-badge {
      position: absolute;
      bottom: 2px;
      left: 2px;
      padding: 1px 5px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 600;
      pointer-events: none;
    }

    .thumb .status-badge.done {
      background: rgba(46, 204, 113, .85);
      color: #fff;
    }

    .thumb .status-badge.processing {
      background: rgba(74, 158, 255, .85);
      color: #fff;
    }

    /* Preview */
    .preview-section {
      margin-top: 2rem;
    }

    .preview-section h2 {
      font-size: 1.1rem;
      font-weight: 500;
      margin-bottom: .8rem;
      color: #aaa;
    }

    .preview-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }

    @media (max-width: 700px) {
      .preview-grid {
        grid-template-columns: 1fr;
      }
    }

    .preview-card {
      background: #181818;
      border: 1px solid #333;
      border-radius: 10px;
      overflow: hidden;
    }

    .preview-card-header {
      padding: .6rem 1rem;
      font-size: .85rem;
      color: #888;
      border-bottom: 1px solid #282828;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .preview-card-header .filename {
      color: #ccc;
      font-weight: 500;
    }

    .preview-card-header .dimensions {
      color: #555;
      font-size: .8rem;
    }

    .preview-card-body {
      background: repeating-conic-gradient(#222 0% 25%, #2a2a2a 0% 50%) 50% / 20px 20px;
      padding: 1rem;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 150px;
    }

    .preview-card-body canvas {
      max-width: 100%;
      height: auto;
      display: block;
    }

    /* Progress */
    .progress-bar-container {
      margin-top: 1.5rem;
      display: none;
    }

    .progress-bar-container.visible {
      display: block;
    }

    .progress-label {
      font-size: .85rem;
      color: #888;
      margin-bottom: .4rem;
      display: flex;
      justify-content: space-between;
    }

    .progress-track {
      height: 6px;
      background: #222;
      border-radius: 3px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: #4a9eff;
      border-radius: 3px;
      transition: width .3s;
      width: 0%;
    }

    /* Info box */
    .info-box {
      margin-top: 1.5rem;
      padding: 1rem;
      background: #181818;
      border: 1px solid #333;
      border-radius: 10px;
      font-size: .85rem;
      color: #888;
      line-height: 1.6;
    }

    .info-box strong {
      color: #aaa;
    }

    footer {
      text-align: center;
      padding: 2rem 1rem;
      color: #444;
      font-size: .8rem;
    }

    footer a {
      color: #4a9eff;
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>

<header>
  <h1>Alpha Bleed Fix</h1>
  <p>Fix dark edges on transparent images caused by bilinear interpolation</p>
</header>

<div class="container">

  <div class="drop-zone" id="dropZone">
    <input type="file" id="fileInput" multiple accept="image/png,image/webp">
    <div class="icon">+</div>
    <div class="label">Drop images here or click to browse</div>
    <div class="sublabel">PNG, WebP &mdash; images with transparency</div>
  </div>

  <div class="controls">
    <div class="control-group">
      <label>Output Format</label>
      <select id="outputFormat">
        <option value="png">PNG</option>
        <option value="webp">WebP</option>
      </select>
    </div>
    <div class="spacer"></div>
    <button class="btn btn-danger" id="clearBtn" disabled>Clear All</button>
    <button class="btn btn-primary" id="processBtn" disabled>Fix Images</button>
    <button class="btn btn-success" id="downloadBtn" disabled>Download All</button>
  </div>

  <div class="thumbnails" id="thumbnails"></div>

  <div class="progress-bar-container" id="progressContainer">
    <div class="progress-label">
      <span id="progressText">Processing...</span>
      <span id="progressPercent">0%</span>
    </div>
    <div class="progress-track">
      <div class="progress-fill" id="progressFill"></div>
    </div>
  </div>

  <div class="preview-section" id="previewSection" style="display:none">
    <h2>Before &amp; After</h2>
    <div id="previewList"></div>
  </div>

  <div class="info-box">
    <strong>What is alpha bleeding?</strong><br>
    When images with transparency are scaled using bilinear interpolation (as Roblox does),
    the GPU averages nearby pixel colors &mdash; including fully transparent pixels that often
    contain black (0, 0, 0) RGB values. This causes dark edges/fringing around transparent
    boundaries. Alpha bleeding fills the RGB of transparent pixels with colors from their
    nearest opaque neighbors, so interpolation produces correct results while keeping the
    alpha channel unchanged.
  </div>

</div>

<footer>
  Alpha Bleed Fix &mdash; runs entirely in your browser &mdash;
  <a href="https://github.com/gatekeeperdev/alpha-bleed-fix" target="_blank">GitHub</a>
</footer>

<script>
(function () {
  const dropZone = document.getElementById('dropZone');
  const fileInput = document.getElementById('fileInput');
  const thumbnailsEl = document.getElementById('thumbnails');
  const outputFormatSelect = document.getElementById('outputFormat');
  const clearBtn = document.getElementById('clearBtn');
  const processBtn = document.getElementById('processBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const progressContainer = document.getElementById('progressContainer');
  const progressText = document.getElementById('progressText');
  const progressPercent = document.getElementById('progressPercent');
  const progressFill = document.getElementById('progressFill');
  const previewSection = document.getElementById('previewSection');
  const previewList = document.getElementById('previewList');

  let images = []; // { name, img, w, h, originalData, fixedCanvas, processed }

  // --- File handling ---

  dropZone.addEventListener('dragover', (e) => {
    e.preventDefault();
    dropZone.classList.add('dragover');
  });

  dropZone.addEventListener('dragleave', () => {
    dropZone.classList.remove('dragover');
  });

  dropZone.addEventListener('drop', (e) => {
    e.preventDefault();
    dropZone.classList.remove('dragover');
    handleFiles(e.dataTransfer.files);
  });

  fileInput.addEventListener('change', (e) => {
    handleFiles(e.target.files);
    fileInput.value = '';
  });

  function handleFiles(fileList) {
    const files = Array.from(fileList).filter(f => f.type.startsWith('image/'));
    if (!files.length) return;

    const promises = files.map(file => {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            resolve({
              name: file.name.replace(/\.[^.]+$/, ''),
              ext: file.name.split('.').pop(),
              img,
              w: img.naturalWidth,
              h: img.naturalHeight,
              fixedCanvas: null,
              processed: false
            });
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      });
    });

    Promise.all(promises).then(newImages => {
      images.push(...newImages);
      downloadBtn.disabled = true;
      updateUI();
    });
  }

  // --- UI ---

  function updateUI() {
    renderThumbnails();
    clearBtn.disabled = images.length === 0;
    processBtn.disabled = images.length === 0;
    if (images.length === 0) {
      previewSection.style.display = 'none';
      downloadBtn.disabled = true;
      progressContainer.classList.remove('visible');
    }
  }

  function renderThumbnails() {
    thumbnailsEl.innerHTML = '';
    images.forEach((item, i) => {
      const div = document.createElement('div');
      div.className = 'thumb';
      div.title = item.name + ' (' + item.w + '\u00d7' + item.h + ')';

      const img = document.createElement('img');
      img.src = item.img.src;
      div.appendChild(img);

      const btn = document.createElement('button');
      btn.className = 'remove';
      btn.textContent = '\u00d7';
      btn.onclick = () => {
        images.splice(i, 1);
        downloadBtn.disabled = true;
        updateUI();
        renderPreviews();
      };
      div.appendChild(btn);

      if (item.processed) {
        const badge = document.createElement('span');
        badge.className = 'status-badge done';
        badge.textContent = 'Fixed';
        div.appendChild(badge);
      }

      thumbnailsEl.appendChild(div);
    });
  }

  // --- Alpha bleed algorithm ---
  // Based on https://github.com/urraka/alpha-bleeding
  // BFS flood-fill that propagates RGB from opaque pixels into ALL transparent pixels.
  // Uses bit-masking on an opaque tracking array to correctly handle wavefront expansion.

  function alphaBleed(data, width, height) {
    const offsets = [
      [-1, -1], [0, -1], [1, -1],
      [-1,  0],          [1,  0],
      [-1,  1], [0,  1], [1,  1],
    ];

    // opaque: -1 (0xFFFFFFFF) = original opaque pixel, 0 = unprocessed transparent
    // loose: true = transparent pixel with NO opaque neighbors yet
    const opaque = new Int32Array(width * height);
    const loose = new Uint8Array(width * height);
    let pending = [];
    let pendingNext = [];

    // Classify all pixels
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = y * width + x;
        const si = idx * 4;

        if (data[si + 3] !== 0) {
          // Opaque (or semi-transparent) — mark as source
          opaque[idx] = -1; // all bits set
        } else {
          // Fully transparent — check if adjacent to any non-transparent pixel
          let isLoose = true;
          for (let k = 0; k < 8; k++) {
            const nX = x + offsets[k][0];
            const nY = y + offsets[k][1];
            if (nX >= 0 && nX < width && nY >= 0 && nY < height) {
              if (data[(nY * width + nX) * 4 + 3] !== 0) {
                isLoose = false;
                break;
              }
            }
          }

          if (!isLoose) {
            pending.push(idx);
          } else {
            loose[idx] = 1;
          }
        }
      }
    }

    // Iteratively expand: process pending pixels, then shift bits
    while (pending.length > 0) {
      pendingNext = [];

      for (let p = 0; p < pending.length; p++) {
        const idx = pending[p];
        const x = idx % width;
        const y = (idx - x) / width;

        let r = 0, g = 0, b = 0, count = 0;

        for (let k = 0; k < 8; k++) {
          const nX = x + offsets[k][0];
          const nY = y + offsets[k][1];
          if (nX >= 0 && nX < width && nY >= 0 && nY < height) {
            const nIdx = nY * width + nX;
            // Check lowest bit — means this neighbor has valid RGB
            if (opaque[nIdx] & 1) {
              const nSi = nIdx * 4;
              r += data[nSi];
              g += data[nSi + 1];
              b += data[nSi + 2];
              count++;
            }
          }
        }

        if (count > 0) {
          const si = idx * 4;
          data[si]     = Math.round(r / count);
          data[si + 1] = Math.round(g / count);
          data[si + 2] = Math.round(b / count);
          // Keep alpha at 0
          opaque[idx] = 0xFE;

          // Promote loose neighbors to pending
          for (let k = 0; k < 8; k++) {
            const nX = x + offsets[k][0];
            const nY = y + offsets[k][1];
            if (nX >= 0 && nX < width && nY >= 0 && nY < height) {
              const nIdx = nY * width + nX;
              if (loose[nIdx]) {
                pendingNext.push(nIdx);
                loose[nIdx] = 0;
              }
            }
          }
        } else {
          pendingNext.push(idx);
        }
      }

      // Shift right so newly filled pixels (0xFE >> 1 = 0x7F) still have bit 0 set
      if (pendingNext.length > 0) {
        for (let p = 0; p < pending.length; p++) {
          opaque[pending[p]] >>= 1;
        }
      }

      pending = pendingNext;
    }
  }

  // --- Processing ---

  async function processImages() {
    processBtn.disabled = true;
    downloadBtn.disabled = true;
    progressContainer.classList.add('visible');

    for (let idx = 0; idx < images.length; idx++) {
      const item = images[idx];
      const pct = Math.round(((idx) / images.length) * 100);
      progressText.textContent = 'Processing ' + (idx + 1) + ' of ' + images.length + '...';
      progressPercent.textContent = pct + '%';
      progressFill.style.width = pct + '%';

      // Yield to UI
      await new Promise(r => setTimeout(r, 0));

      const canvas = document.createElement('canvas');
      canvas.width = item.w;
      canvas.height = item.h;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(item.img, 0, 0);

      const imageData = ctx.getImageData(0, 0, item.w, item.h);
      alphaBleed(imageData.data, item.w, item.h);
      ctx.putImageData(imageData, 0, 0);

      item.fixedCanvas = canvas;
      item.processed = true;

      renderThumbnails();
    }

    progressText.textContent = 'Done!';
    progressPercent.textContent = '100%';
    progressFill.style.width = '100%';

    setTimeout(() => {
      progressContainer.classList.remove('visible');
    }, 1500);

    processBtn.disabled = false;
    downloadBtn.disabled = false;

    renderPreviews();
  }

  function renderPreviews() {
    const processed = images.filter(item => item.processed);
    if (processed.length === 0) {
      previewSection.style.display = 'none';
      return;
    }

    previewSection.style.display = 'block';
    previewList.innerHTML = '';

    processed.forEach(item => {
      const grid = document.createElement('div');
      grid.className = 'preview-grid';
      grid.style.marginBottom = '1.5rem';

      // Before card
      const beforeCard = document.createElement('div');
      beforeCard.className = 'preview-card';
      const beforeHeader = document.createElement('div');
      beforeHeader.className = 'preview-card-header';
      beforeHeader.innerHTML = '<span class="filename">Before &mdash; ' + item.name + '</span><span class="dimensions">' + item.w + '\u00d7' + item.h + '</span>';
      const beforeBody = document.createElement('div');
      beforeBody.className = 'preview-card-body';
      const beforeCanvas = document.createElement('canvas');
      beforeCanvas.width = item.w;
      beforeCanvas.height = item.h;
      const beforeCtx = beforeCanvas.getContext('2d');
      beforeCtx.drawImage(item.img, 0, 0);
      beforeBody.appendChild(beforeCanvas);
      beforeCard.appendChild(beforeHeader);
      beforeCard.appendChild(beforeBody);

      // After card
      const afterCard = document.createElement('div');
      afterCard.className = 'preview-card';
      const afterHeader = document.createElement('div');
      afterHeader.className = 'preview-card-header';
      afterHeader.innerHTML = '<span class="filename">After &mdash; ' + item.name + '</span><span class="dimensions">' + item.w + '\u00d7' + item.h + '</span>';
      const afterBody = document.createElement('div');
      afterBody.className = 'preview-card-body';
      const afterCanvas = document.createElement('canvas');
      afterCanvas.width = item.w;
      afterCanvas.height = item.h;
      const afterCtx = afterCanvas.getContext('2d');
      afterCtx.drawImage(item.fixedCanvas, 0, 0);
      afterBody.appendChild(afterCanvas);
      afterCard.appendChild(afterHeader);
      afterCard.appendChild(afterBody);

      grid.appendChild(beforeCard);
      grid.appendChild(afterCard);
      previewList.appendChild(grid);
    });
  }

  // --- Download ---

  function downloadAll() {
    const format = outputFormatSelect.value;
    const mime = format === 'webp' ? 'image/webp' : 'image/png';
    const ext = format === 'webp' ? '.webp' : '.png';

    const processed = images.filter(item => item.processed);
    if (processed.length === 0) return;

    if (processed.length === 1) {
      // Single file: download directly
      processed[0].fixedCanvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = processed[0].name + '_fixed' + ext;
        a.click();
        URL.revokeObjectURL(url);
      }, mime);
    } else {
      // Multiple files: download as zip using JSZip-like inline approach
      downloadAsZip(processed, mime, ext);
    }
  }

  async function downloadAsZip(items, mime, ext) {
    // Dynamically load JSZip if not already present
    if (typeof JSZip === 'undefined') {
      await new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }

    const zip = new JSZip();

    for (const item of items) {
      const blob = await new Promise(r => item.fixedCanvas.toBlob(r, mime));
      zip.file(item.name + '_fixed' + ext, blob);
    }

    const content = await zip.generateAsync({ type: 'blob' });
    const url = URL.createObjectURL(content);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'alpha_bleed_fixed' + '.zip';
    a.click();
    URL.revokeObjectURL(url);
  }

  // --- Controls ---

  clearBtn.addEventListener('click', () => {
    images = [];
    updateUI();
  });

  processBtn.addEventListener('click', () => {
    processImages();
  });

  downloadBtn.addEventListener('click', () => {
    downloadAll();
  });
})();
</script>

</body>
</html>
